# 核心框架

## 导演

### 设置帧率

帧率是用于测量显示帧数到量度，其单位为“每秒显示帧数”（Frame per Second, FPS）。一般情况下，电影以 **24fps** 播放，而在游戏中如果帧率低于 **30fps** 的话，游戏就会显得卡顿不连贯。在 Cocos2d-JS 中，帧率默认为 **60fps**。若想修改默认帧率，可以直接修改工程下 project.json 文件中 frameRate 的值。

在游戏运行中，`cc.Director` 也提供了动态操作帧率的 API，你可以调用 `cc.director.setAnimationInterval(fps)` 方法来更改帧率。**需要注意的是，这里的参数 fps 是帧率的倒数，表示游戏每秒绘制多少次**

```javascript
cc.director.setAnimationInterval(1.0 / 60);
```

### 初始化管理器

导演好比一艘船的船长，是整个游戏的统筹。它需要一些帮手来分担任务。这些帮手就是调度器、动作管理器、事件管理器。这些管理器，对应管理着自己的领域，它们都在 `cc.Director` 的 `init()` 方法中被初始化。

```javascript
// frameworks/cocos2d-html5/cocos2d/core/CCDirector.js
cc.Director = cc.Class.extend(/** @lends cc.Director# */{
    init: function () {
        //scheduler
        this._scheduler = new cc.Scheduler();
        //action manager
        if (cc.ActionManager) {
            this._actionManager = new cc.ActionManager();
            this._scheduler.scheduleUpdate(this._actionManager, cc.Scheduler.PRIORITY_SYSTEM, false);
        } else {
            this._actionManager = null;
        }

        this._eventAfterUpdate = new cc.EventCustom(cc.Director.EVENT_AFTER_UPDATE);
        this._eventAfterUpdate.setUserData(this);
        this._eventAfterVisit = new cc.EventCustom(cc.Director.EVENT_AFTER_VISIT);
        this._eventAfterVisit.setUserData(this);
        this._eventAfterDraw = new cc.EventCustom(cc.Director.EVENT_AFTER_DRAW);
        this._eventAfterDraw.setUserData(this);
        this._eventProjectionChanged = new cc.EventCustom(cc.Director.EVENT_PROJECTION_CHANGED);
        this._eventProjectionChanged.setUserData(this);

        return true;
    }
```

### 初始化渲染器

渲染器用于将图片或者 3D 模型素材绘制到屏幕上。因为 Cocos2d-JS 是一个跨全平台的游戏引擎，使用它开发出来的游戏可以运行在浏览器和本地上，所以，在各平台上采用的渲染器也是不一样的。

在 HTML5 中，iOS 8 以上以及所有 PC 系统中，默认采用 **WebGL** 渲染，其他浏览器采用 **canvas** 绘制，例如 Android 手机上的浏览器。

在 Native 上，全部采用 **OpenGL ES 2.0** 渲染。

### 获取屏幕大小

在游戏开发中，时常需要获取当前屏幕大小，然后参考屏幕的大小将游戏中的可视对象定位在屏幕上。`cc.Director` 提供了几种不同概念的屏幕大小。

```javascript
cc.Diretor = cc.Class.extend({
    getWinSize: function () {
        return cc.size(this._winSizeInPoints);
    },
    getWinSinzeInPixels: function () {
        return cc.size(this._winSizeInPoints.width * this._contentScaleFactor, this._winSizeInPoints.height * this._contentScaleFactor);
    },
    getVisibleSize: null,
    getVisibleOrigin: null
});
```

其中 `WinSize` 表示实际画布的大小，`VisibleSize` 表示可视区域的大小，所以，`VisibleSize` 总是小于或者等于 `WinSize`。值得注意的是，`VisibleSize` 和 `VisibleOrigin` 是为 Native 服务的，仅在 JSB 上有效。另外，在 CCBoot.js 中实现了这样一行代码：

```javascript
cc.winSize = cc.director.getWinSize();
```

因此，你可以通过 `cc.winSize` 的方式快速获取屏幕的大小。

### 执行游戏主循环

当游戏的底层环境设置好之后，游戏就可以以设定好的帧率（默认为 60fps）进入主循环了。cc.Director 定义了一个 `mainLoop` 方法，该方法控制着整个游戏的主循环。你可以在 `CCDirector.js` 中看到这样一段代码：

```javascript
cc.Director = cc.Class.extend({
    mainLoop: function () {
        if (this._purgeDirectorInNextLoop) {
            this._purgeDirectorInNextLoop = false;
            this.purgeDirector();
        } else if (!this.invaild) {
            this.drawScene();
        }
    }
});
```

- **是否需要清除自身**：首先，cc.Director 会去检查下一帧是否需要清除自身，一般在调用 cc.director.end() 时触发，这将清理和退出正在运行的场景，并且取消所有的调度器，删除所有的事件监听器，停止所有的动画以及清空缓存数据。
- **开始绘制场景**：然后，开始绘制场景，Cocos2d-JS 首先会去计算增量时间，即上一帧到现在所花的时间。理论上，它的值总是大于或者等于游戏设定的帧率的倒数。**所以，增量时间越大，游戏越显得卡顿。当增量时间大于一定值的时候，游戏开始出现明显的掉帧现象。**
- **执行调度器**：接着 cc.Director 开始执行调度器中所被要求执行的任务。例如，《飞机大战》游戏中的飞机每隔 0.5s 发射子弹，若游戏以 60fps 来绘制，它大概是每隔 30 帧创建一颗子弹出来。若当前帧与上一次发射子弹刚好间隔了 30 帧，那这一次的子弹就会在当前帧被创建出来。
- **触发 cc.director.EVENT_AFTER_UPDATE 事件**：在执行调度器中的任务之后，cc.Director 通过事件管理器触发 cc.director.EVENT_AFTER_UPDATE 事件，然后 Cocos2d-JS 开始检查是否有用户交互事件触发，例如触摸事件、鼠标实现、键盘事件、重力感应事件以及自定义事件，若有，则分发和处理这些事件。
- **绘制节点**：事件分发完毕之后，渲染器把整个屏幕都清空掉，这是非常合理的。因为当渲染器清空完屏幕之后，导演开始判断是否有场景需要切换，若有，则切换到下一个场景，若没有，则遍历当前场景中的节点并更新节点的空间转换矩阵等信息，然后发送绘制指令给渲染器。接着，cc.Director 触发 cc.director.EVENT_AFTER_VISIT 事件，并且会把所有的字节点**按照层级从小到大进行排序**，排序之后，所以字节点的 `visit()` 方法将被触发。也正是在这个方法中，节点被绘制出来。
- **更新当前帧率**：节点绘制完毕后，cc.Director 触发 cc.director.EVENT_AFTER_DRAW 事件，最终更新当前帧率。

## Cocos2d-JS 坐标系

渲染器渲染游戏对象时，需要获取游戏对象的位置。

在手机移动应用中，坐标系通常分为两种——屏幕坐标系和 OpenGL 坐标系。传统的原生应用采用的是屏幕坐标，即以屏幕的左上角为原点，向右表示 X 轴的正方向，向下表示 Y 轴的正方向，这不管是在 iOS、Android 还是   Windows Phone 中，都是一样的。

然而，Cocos2d-JS 并不是采用屏幕坐标系，而是选择了和 OpenGL 保持一致，即以屏幕的左下角为原点，向右表示 X 轴的正方向，向上表示 Y 轴的正方向。

![](3a.png)

另外，cc.Director 提供了屏幕坐标和 OpenGL 坐标二者之间互相转换的方法

```javascript
convertToGL = function (uiPoint)		// 转换 UI 坐标为 OpenGL/WebGL 坐标
convertToUI = function (glPoint)		// 转换 OpenGL/WebGL 坐标为 UI 坐标
```

除此之外，Cocos2d-JS 中还有世界坐标系和本地坐标系的概念。

## 节点

节点，是一个代词，它是一个抽象概念类，在 Cocos2d-JS 中为 `cc.Node` 类。也就是说，所有 cc.Node 类及其子类，都可以归称为节点。cc.Node 本身没有可视化表示形式，但凡是能被绘制，或者能包含其他节点的东西都是节点，例如场景（cc.Scene）、层（cc.Layer）、精灵（cc.Sprite）等。所有的节点都继承自 cc.Node，cc.Node 定义了所有节点共有的属性和方法。

### 基础属性

#### 位置

位置是节点最基础的属性，默认为 cc.p(0, 0)，大部分的节点你我们都需要给它设置一个位置。

位置相关的 API：

| 属性      | 对应方法                            | 参数或返回类型       | 说明                |
| --------- | ----------------------------------- | -------------------- | ------------------- |
| x         | setPositionX(posX)                  | Number               | 设置节点的 X 轴坐标 |
|           | getPositionX()                      | Number               | 获取节点的 X 轴坐标 |
| y         | setPositionY(posY)                  | Number               | 设置节点的 Y 轴坐标 |
|           | getPositionY()                      | Number               | 获取节点的 Y 轴坐标 |
| _position | setPosition(newPosOrxValue, yValue) | cc.p(x, y) 或 Number | 设置节点的坐标      |
|           | getPosition()                       | Number               | 获取节点的坐标      |

**属性前面带有下划线（_）的，均表示私有属性，子类不可访问，例如 cc.Node 的 _position 属性。**

```javascript
// 通过属性方式
node.x = 100; // 设置 x 轴坐标
node.y = 86; // 设置 y 轴坐标
var posX = node.x; // 获取 x 轴坐标
var posY = node.y; // 获取 y 轴坐标

// 通过方法形式
node.setPosition(100, 86); // 设置坐标
node.setPosition(cc.p(100, 86)); // 设置坐标
node.getPosition(); // 获取坐标，返回 cc.p 类型

```

Cocos2d-JS 提供了两种操作属性的方法，第一种是直接通过属性风格操作属性，第二种是通过函数调用。虽然通过属性操作的方式更加简便，但是属性风格的实现用到 ECMAScript 的 getter 和 setter 的特性，**这两个特性在部分浏览器上面的效率要低于方法**，所以在对性能要求比较高的地方还是建议使用方法进行访问。

> cc.defineGetterSetter(proto, prop, getter,setter) 函数实现了 ECMAScript 的 getter 和 setter 特性，你可以在 cocos2d-x/cocos/scripting/js-bindings/script/jsb_boot.js （Native 实现）或 cocos2d-x/web/cocos2d/core/platform/CCClass.js（web 实现）中看到它的实现。

#### 大小

在开发中，可能需要设置或获取节点的大小，例如在做碰撞检测的时候。

节点大小的相关 API：

| 属性         | 对应方法                     | 参数或返回类型     | 说明               |
| ------------ | ---------------------------- | ------------------ | ------------------ |
| _contentSize | setContentSize(size, height) | Number             | 设置节点的内容大小 |
|              | getContentSize()             | cc.size() 数据结构 | 获取节点内容大小   |

```javascript
// 通过属性的方式快速访问节点的大小值
node.width = 100; // 设置节点的宽度
node.height = 200; // 设置节点的高度
var width = node.width; // 获取节点的宽度
var height = node.height; // 获取节点的高度
```

**值得注意的是，这里设置的内容大小并不会改变节点的视觉效果，它只是一个属性，一般也被用到触摸事件中。**

> cocos2d-x/web/cocos2d/core/base-nodes/BaseNodes/PropertyDefine.js 实现了节点的属性访问方式，例如 node.height 的实现如下：
>
> ```javascript
> var _p = cc.Node.prototype;
> _p.height;
> cc.defineGetterSetter(_p, "height", _p._getHeight, _p.setHeight);
> ```
>
> 除此之外，其他类的属性方式也是这样实现的。

#### 锚点

锚点，它是一个百分比系数，其取值范围为[0, 0] 到 [1, 1]，边界包含 0 和 1。每种类型的节点都会有自己的默认值，例如 cc.Node 类的默认节点为 cc.p(0, 0)，表示节点的左下角定位在屏幕上你所设定的位置。所以，位置和锚点这两个属性共同决定了节点在屏幕中的摆放位置。

```javascript
node.setAnchorPoint(0.5, 0.5); // 设置锚点
var anchor = node.getAnchorPoint(); // 获取锚点，返回 cc.p 类型
```

节点定位在屏幕上的定位点（称为原点）的算法：

> x 轴坐标：节点宽度 * 锚点 x 值
>
> y 轴坐标：节点高度 * 锚点 y 值

也可以通过 cc.Node 的 `getAnchorPointInPoints()` 函数直接获取原点。

除此之外，锚点还决定节点变换操作，例如旋转和缩放等。因为动作是基于变换操作的，所以锚点也是动作运转的围绕点。

#### 层级

若当游戏中只有一个节点，渲染器可以直接对此节点进行绘制。但是，倘若游戏中有两个以上的节点需要绘制，那么渲染器可能会不知所措，因为它并不知道要将哪个节点绘制在屏幕的最上方，哪个节点绘制在屏幕的最下方。所以，每个节点都会有一个层级属性，用来告诉渲染器节点的绘制顺序。

层级又分为全局层级和本级层级两种，全局层级用 globalZOrder 表示，本地层级用 localZOrder 表示，全局层级的绘制优先级高于本地层级。

获取和设置层级的相关 API ：

| 属性          | 对应方法                      | 参数或返回类型 | 说明               |
| ------------- | ----------------------------- | -------------- | ------------------ |
| zIndex        | setLocalZOrder(localZOrder)   | Number         | 设置节点的本地层级 |
|               | getLocalZOrder()              | Number         | 获取节点的本地层级 |
| _globalZOrder | setGlobalZOrder(globalZOrder) | Number         | 设置节点的全局层级 |
|               | getGlobalZOrder()             | Number         | 获取节点的全局层级 |

一般情况下，层级保持默认值即可。在开发中，能少用层级的就尽量少用层级，免得节点层级关系乱七八糟点，给自己带来麻烦。若在一些非用层级不可的地方，那么建议定义一个类似枚举的层级对象，向下面那样：

```javascript
var NodeZorder = NodeZorder || {};
NodeZorder.HERO = 100; // 角色对象层级
NodeZorder.ROLE = 200; // 角色对象层级
// ...
this.addChild(node, NodeZorder.HERO); // 将节点添加到当前层中
```

#### 标签

在游戏中可能同时存在好多个节点，你可以为每个节点都贴上一个标签，方便区分它们。cc.Node 提供了一个叫 tag 的属性，默认值为 -1， 是 Number 类型。

设置和获取节点 tag 值的 API ：

| 属性 | 对应方法    | 参数或返回类型 | 说明           |
| ---- | ----------- | -------------- | -------------- |
| tag  | setTag(tag) | Number         | 设置节点的标签 |
|      | getTag()    | Number         | 获取节点的标签 |

*注意：cc.Node 的 tag 值必须为整型，否则在 JSB 上会报错，这是因为 Cocos2d-x API 设计的就是整型的。*

#### 名字

用 tag 标记节点的方式可能不能完全满足开发需求。因为 tag 为整型类型，虽然我们可以通过定义常量的方式将 tag 值中转一下，但是若 tag 值相等的话，节点依旧无法根据 tag 值区分，就像下面这样：

```javascript
MAN = 1;
WOMAN = 1;
var man = new cc.Node(); // 创建节点
man.setTag(MAN);	// 设置 tag 属性
var woman = new cc.Node(); // 创建节点
woman.setTag(WOMAN); // 设置 tag 属性
```

所以，Cocos2d-JS 也为节点设计了 name 属性，它是字符串类型的。

name 属性对应的方法

| 属性 | 对应方法      | 参数或返回类型 | 说明           |
| ---- | ------------- | -------------- | -------------- |
| name | setName(name) | String         | 设置节点的名字 |
|      | getName()     | String         | 获取节点的名字 |

