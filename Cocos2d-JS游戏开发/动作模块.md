# 动作模块

## cc.Action

动作作用于 cc.Node，每个节点都可以通过 runAction(action) 函数运行一个或多个动作，每个动作保存着指定的规则供节点运作。在 Cocos2d-JS 中，动作对应的类是 cc.Action，它是所有动作类的父类，其构造函数如下：

```javascript
cc.Action = cc.Class.extend({
    originalTarget: null,
    target: null,
    tag: cc.ACTION_TAG_INVALID,
    ctor: function () {
        this.originalTarget = null;
        this.target = null;
        this.tag = cc.ACTION_TAG_INVALID;
    }
    // ......
});
```

该类定义了 3 个属性：初始目标（originalTarget）、目标（target）以及动作标签（tag）。动作是允许克隆的，originalTarget 始终指向第一次运行此动作的节点，而 target 则为当前正在运行此动作的节点，tag 则是一个动作的唯一标识，它的默认值为 -1。tag 一般被用在 cc.Node 的 stopActionByTag(tag) 等函数中。

动作类的大多数实现类都继承有限时间类（cc.FiniteTimeAction），cc.FiniteTimeAction 类定义了 reverse() 函数，调用此函数可以获得一个与当前动作相反的动作，这称为逆动作。例如，一个精灵运行了旋转负 45<sup>o</sup> 的动作，那么调用 reverse() 函数，将返回一个旋转正 45 <sup>o</sup> 的动作，但是并不是所有的动作都可返回逆动作。另外，cc.FiniteTimeAction 还派生出瞬间动作 cc.ActionInstant 和持续动作 cc.ActionInterval，它们各自的子类继承关系如图所示：

![](4a.png)

## 瞬间动作

在一帧内执行结束的动作称为瞬间动作。cc.ActionInstant 是所有瞬间动作类的父类，例如 cc.Place、cc.Hide、cc.RemoveSelf 等都是瞬间动作。

### cc.Place

cc.Place 的作用是将节点放置到某个指定位置，实际上它只是修改了节点的 position 坐标。所以，若你想通过一个动作将节点放置到屏幕坐标(100, 86)，可以像下面这样做：

```javascript
var place = cc.place(100, 86);
node.runAction(place);
```

> Cocos2d-JS 简化了动作的创建方式，为所有的动作定义了快速创建的函数。例如，cc.place 函数的实现如下：
>
> ```javascript
> cc.place = function (pos, y) {
>     return new cc.place(pos, y);
> };
> ```

### cc.FilpX 和 cc.FilpY

cc.FilpX 和 cc.FilpY 这两个动作在本质上是一样的，只是作用的方向不同。cc.FilpX 是将目标水平翻转，而 cc.FilpY  则是将目标垂直翻转，true 和 false 表示是否翻转。一般情况下，cc.FilpX 和 cc.FilpY 作用于 cc.Sprite 或 cc.Sprite 的字类上，代码如下：

```javascript
var filpX = cc.filpX(true);
var filpY = cc.filpY(false);
```

### cc.Show 和 cc.Hide

几乎所有即时动作的实现都是直接修改其对应的属性，cc.Show 和 cc.Hide 也不例外。cc.Show 和 cc.Hide 通过修改节点的 visible 属性来达到显示和隐藏的功能。通过下列代码可以创建一个显示或隐藏的动作：

```javascript
var show = cc.show(); // 创建一个 显示 动作
var hide = cc.hide(); // 创建一个 隐藏 动作
```

### cc.ToggleVisibility

cc.ToggleVisibility 动作可以切换节点的可视（Visibility）属性，当节点可见时，运行此动作，则节点会被隐藏，反之同理。创建 cc.ToggleVisibility 动作的代码如下：

```javascript
var toggleVisibility = cc.toggleVisibility();
```

### cc.RemoveSelf

顾名思义，cc.RemoveSelf 就是将正在运行此动作的节点从父节点移除，它实际是调用了 target（正在运行此动作的节点）的 removeFromParent(isNeedCleanUp) 函数。你可以在 cc.RemoveSelf 的 update 函数中看到如下代码：

```javascript
update: function () {
    this.target.removeFromParent(this._isNeedCleanUp);
}
```

cc.RemoveSelf 类中声明了一个属性 `_isNeedCleanUp`，该属性默认为 true，表示目标节点以及它所关联的动作、调度器等都将被移除。若 `_isNeedCleanUp` 为 false，则只移除目标节点。

cc.RemoveSelf 的构造函数是一个有参构造函数，因为 _isNeedCleanUp 的默认值为 true，所以在实际开发中可以省略这个参数，相关代码如下：

```javascript
var moveSelf = cc.removeSelf(); // 等同于 cc.removeSelf(true)
var moveSelf = cc.removeSelf(false); 
```

### cc.CallFunc

cc.CallFunc 是即时动作中较为特殊的一种，它将一个函数包装成动作，当节点运行此动作的时候，便会回调此函数。通常情况下，cc.CallFunc 会结合复合动作使用。例如，主角 2 秒内移到屏幕(100, 200)后，说了一句“我已经到达指定地点”。那么，这个功能的实现代码如下：

```javascript
var moveTo = cc.moveTo(2, cc.p(100, 200));
var callback = cc.callFunc(function () {
    cc.log("我已经到达指定地点");
}.bind(this));
node.runAction(cc.sequence(moveTo, callback));
```

## 持续动作

需要持续一点时间才能完成的动作称为持续动作，例如花 2 秒的时间让精灵移动到屏幕坐标(300, 200)的位置。由于持续动作需要持续一端时间才能完成，所以所有得持续动作都需要接收一个用于控制动作执行时间的参数 duration。

大部分的持续动作可以分为两种——xxTo 和 xxBy，前者表示最终值，而后者表示相对改变值。

```javascript
var moveTo = cc.moveTo(1, cc.p(-20, 50)); // 用 1 秒时间将节点移动到屏幕坐标为(-20, 50)的位置
var moveBy = cc.moveBy(1, cc.p(-20, 50)); // 相对当前坐标进行 X 轴偏移 -20，Y 轴偏移 50
```

根据持续动作的作用不同，我们将持续动作分为属性变化动作和视觉特效动作两大类。

### 属性变化动作

属性变化动作，即运行动作的过程中会改变节点对应属性的动作，它们大概有如下几种。

#### cc.MoveTo 和 cc.MoveBy

Move 动作使节点做直线运动，通常用来移动游戏内的角色等，其函数原型如下：

```javascript
cc.moveTo(duration, position, y);
cc.moveBy(duration, position, y);
```

其中，参数 duration 为持续时间，position 可以为 cc.p(x, y) 类型的值，也可以为坐标的 x 值。当 position 为 cc.p(x, y) 时，y 可以省略。

```javascript
// 用时 1 秒，将节点移动到屏幕(128, 80) 的位置
var moveTo = cc.moveTo(1, cc.p(125, 80)); // 等同于 cc.moveTo(1, 125, 80)
// 用时 1 秒，节点相对当前坐标，X 轴向左移动 88，Y 轴向上移动 99
var moveBy = cc.moveBy(1, cc.p(-88, 99)); // 等同于 cc.moveBy(1, -88, 99)
```

#### cc.jumpTo 和 cc.jumpBy

jump 动作以一定的轨迹让节点跳跃到指定的位置，其 API 如下：

```javascript
cc.jumpTo(duration, position, y, height, jumps);
cc.jumpBy(duration, position, y, height, jumps);
```

可以发现，形参中也有 position，这意味着若传入进去的参数为 cc.p(x, y) 类型的参数，则 y 同样可以省略。height 为跳跃高度，jumps 为跳跃的次数。

```javascript
// 1 秒时间，跳到(100, 86)，跳跃高度为 50 像素，总共跳跃 4 次
var jumpTo = cc.jumpTo(1, cc.p(100, 86), 50, 4);
// 1 秒时间，原地跳，跳跃高度为 100 像素，总共跳跃 4 次
var jumpBy = cc.jumpBy(1, cc.p(0, 0), 100, 4);
node.runAction(cc.sequence(jumpTo, jumpBy));
```

> cc.sequence 动作将一组动作包装成一个序列，然后挨个执行。

#### cc.BezierTo 和 cc.BezierBy

Bezier 动作可以让节点做曲线运动，而曲线则由贝塞尔曲线描述。贝塞尔曲线又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。

每条贝塞尔曲线都包含一个起点和一个终点。在一条曲线中，起点和终点各自包含一个控制点，而控制点到起点（或终点）的连接线称作控制线，所以每条贝塞尔曲线应该有两条控制线和两个控制点。控制点和起点（或终点）的角度以及长度决定了曲线的形状

![](4b.png)

Bezier 动作的 API 如下：

```javascript
cc.bezierTo(duration, control);
cc.bezierBy(duration, control);
```

其中，control 参数为贝塞尔曲线的描述信息，它接收三个点坐标，分别是起点控制点、终点控制点、终点。所以，当你需要创建一个 Bezier 动作时，应该先配置好贝塞尔曲线的描述信息

```javascript
var size = cc.winSize;
// 条件：当前节点坐标为 cc.p(0, 0)
// 要求：用 1 秒时间做贝塞尔曲线运动，将节点从当前位置移动到屏幕右下角
var bezierToConfig = [
    cc.p(0, size.height),	// 起点控制点
    cc.p(size.width, size.height),	// 终点控制点
    cc.p(size.width, 0)	// 终点
];
var bezierTo = cc.bezierTo(1, bezierToConfig);

// 条件：当前节点坐标为 cc.p(cc.winSize.width, 0)
// 要求：用 1 秒时间做相对贝塞尔曲线运动，将 X 轴往负方向移动到屏幕宽度的一半
var bezierByConfig = [
    cc.p(0, size.height),
    cc.p(-size.width / 2, size.height),
    cc.p(-size.width / 2, 0)
];
var bezierBy = cc.bezierBy(1, bezierByConfig);
node.runAction(cc.sequence(bezierTo, bezierBy));
```

实际上，在 Adobe Photoshop中，钢笔工具就是贝塞尔曲线的应用。所以，在开发中，我们可以利用 Adobe Photoshop 的钢笔工具调出贝塞尔曲线，然后将参数搬到代码中，即可得到你想要的 Bezier 动作。

#### cc.ScaleTo 和 cc.ScaleBy

scale 动作可以让节点在指点的时间内进行缩放，其 API 如下：

```javascript
cc.scaleTo(duration, sx, sy);
cc.scaleBy(duration, sx, sy);
```

可以发现，除了 duration 参数之外，还有 sx 和 sy 这两个参数，它们分别表示 X 轴和 Y 轴上的缩放。但是在实际开发中，更多的需求是对整个节点进行缩放，所以，你只需指定一个整体缩放系数即可。这使得 sy 参数必定成为一个可以省略的参数，当 sy 省略时，cc.ScaleTo 或 cc.ScaleBy 的 _endScaleY 属性会被强制设置为 sx 的值，这样便可实现 X 轴和 Y 轴的缩放比例一致。

```javascript
// 用 1 秒的时间，把图片缩放到 原始 大小的 50%
var scaleTo = cc.scaleTo(1, 0.5);
// 用 1 秒的时间，把图片缩放到 当前 大小的 200%
var scaleBy = cc.scaleBy(1, 2);
// 用 1 秒时间，把 X 方向缩放到 原始 大小的 50%，Y 方向缩放到 原始 大小的 150%
var scale = cc.scaleBy(1, 0.5, 1.5);
var scaleReverse = scale.reverse();
node.runAction(cc.sequence(scaleTo, scaleBy, scale, scaleReverse));
```

#### cc.RotateTo 和 cc.RotateBy

Rotate 动作用于旋转节点，其 API 如下：

```javascript
cc.rotateTo(duration, deltaAngleX, deltaAngleY);
cc.rotateBy(duration, deltaAngleX, deltaAngleY);
```

和 Scale 类似，cc.rotateTo(或 cc.rotateBy)的 deltaAngleY 也是可省略的。

```javascript
// 用 1 秒时间，将 X 轴旋转到 -90 度，Y 轴旋转到 -45 度
var rotate = cc.rotateTo(1, -90, -45);
// 用 1 秒时间，整体旋转到 90 度
var rotateTo = cc.rotateTo(1, 90);
// 用 1 秒时间，基于 当前 的角度整体旋转 -90 度
var rotateBy = cc.rotateBy(1, -90);
```

> 在 Cocos2d-JS中，垂直 X 轴向上表示 0 度，垂直 Y 轴向右表示 90 度。