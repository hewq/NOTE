Vue 的响应式系统依赖于一个核心的概念：**依赖收集**。当你访问某个数据时，Vue 会自动跟踪哪些组件或计算属性依赖于这个数据，并在数据发生变化时通知它们进行更新。这一过程是由 **getter 和 setter** 配合 Vue 的 **Observer** 模式实现的。

### Vue 如何收集依赖

1. **数据劫持 (Object.defineProperty)**

   在 Vue 2.x 中，响应式系统通过 `Object.defineProperty` 来实现对数据对象属性的劫持。当你访问数据对象的属性时，`getter` 会被触发，此时 Vue 会把当前的访问者（即正在渲染的组件或计算属性）注册为这个属性的依赖。

2. **响应式对象 (Observer)**

   Vue 会将每个对象转化为响应式对象。每个响应式对象都会有一个 `__ob__` 属性，指向它的观察者（Observer）实例。每个属性的 `getter` 会检查当前的依赖（即是否有正在渲染的组件或计算属性需要重新计算）。

3. **Dep (依赖收集器)**

   每个被 `Object.defineProperty` 劫持的属性都有一个 `Dep` 实例。`Dep` 是依赖收集的核心，负责管理和触发依赖的更新。每个属性的 `getter` 会触发 `Dep.depend()`，将当前的依赖（例如组件或计算属性）注册到 `Dep` 中。

4. **Watcher (观察者)**

   每个组件实例或者计算属性都有一个与之关联的 `Watcher` 实例。`Watcher` 是 `Dep` 的订阅者，用来接收属性变化的通知并执行视图更新。每次组件渲染时，Vue 会将该组件的 `Watcher` 对象推入一个全局的 `Dep.target` 栈中。

5. **依赖收集过程**

   - 在渲染过程中，Vue 会通过访问数据对象的属性来触发 `getter`，此时 `getter` 会向 `Dep` 注册当前的组件或计算属性。
   - `Dep` 会收集所有依赖，当属性发生变化时，`Dep` 会通知所有依赖更新视图。

### 收集依赖的步骤

1. **组件渲染**：当 Vue 渲染一个组件时，组件内的数据会被访问，这些数据的 `getter` 会被触发，进而调用 `Dep.depend()`。
  
2. **注册依赖**：在每个 `getter` 中，Vue 会判断是否有 `Watcher`（即当前组件或计算属性）已经准备好接收数据变化的通知。如果有，则将该 `Watcher` 注册到对应的 `Dep` 中，成为依赖。

3. **数据变化**：当某个响应式属性发生变化时，`setter` 会被触发。触发 `setter` 后，`Dep.notify()` 会通知所有已经注册的依赖（即 `Watcher`），从而更新视图。

### Vue 2.x 中的依赖收集

在 Vue 2.x 中，响应式系统依赖于 `Object.defineProperty`，每个数据属性都拥有自己的 `getter` 和 `setter`。当访问某个属性时，`getter` 会将当前的 `Watcher` 注册到 `Dep` 中。

### Vue 3.x 中的依赖收集

Vue 3.x 使用了 ES6 的 `Proxy` 代替 `Object.defineProperty`，使得 Vue 可以更灵活地处理响应式数据，支持更多的场景（例如动态添加属性）。在 Vue 3 中，`Proxy` 会劫持整个对象的读取操作，并通过 `Reflect` 对象来处理 `get` 和 `set` 操作。

- `Proxy` 的 `get` 拦截器会在访问对象属性时触发依赖收集，`set` 拦截器会触发依赖通知。
- 在 Vue 3 中，`ReactiveEffect` 实现了与 Vue 2 中 `Watcher` 类似的功能，用于观察数据的变化。

### 总结

- Vue 会通过 `getter` 来收集依赖，即在渲染过程中，组件访问数据的属性时，`getter` 会被触发，当前组件会被注册为这个数据的依赖。
- 每个响应式属性都有一个 `Dep` 实例，负责管理依赖，并在属性值变化时通知所有依赖更新。
- Vue 3 使用 `Proxy` 来取代 `Object.defineProperty`，使得响应式系统更加灵活。

通过这样的依赖收集机制，Vue 可以实现数据和视图的高效同步，并且在数据变化时只更新必要的部分，从而提高性能。