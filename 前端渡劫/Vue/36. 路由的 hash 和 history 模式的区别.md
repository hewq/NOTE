在前端路由中，**hash 模式**和**history 模式**是两种常见的实现方式，它们的主要区别在于 URL 表现形式和背后的实现原理。

---

### **1. Hash 模式**

#### **特点**
- URL 中会带有 `#` 符号，例如：`http://example.com/#/home`。
- `#` 后面的内容被称为 **哈希值**，只对前端可见，浏览器不会将其发送到服务器。
- 依赖 `hashchange` 事件监听 URL 的变化。

#### **原理**
- 哈希值的改变不会触发页面的刷新，但可以被 JavaScript 捕获。
- 前端框架监听 `hashchange` 事件，根据哈希值加载对应的组件或视图。

#### **优点**
- **兼容性强**：支持所有现代浏览器，包括一些较旧的浏览器。
- **简单实现**：不需要后端配置支持，完全基于前端。

#### **缺点**
- URL 不美观：`#` 后的哈希值显得多余，不符合常规的 RESTful 风格。
- SEO 不友好：搜索引擎无法抓取 `#` 后的内容（虽然可以通过某些手段解决，但较复杂）。

---

### **2. History 模式**

#### **特点**
- URL 不带 `#`，例如：`http://example.com/home`。
- 依赖 HTML5 的 **History API**，如 `pushState()` 和 `replaceState()` 方法。
- 使用 `popstate` 事件监听 URL 的变化。

#### **原理**
- History API 提供了无刷新修改浏览器历史记录的能力。
- 前端通过调用 `pushState` 和 `replaceState` 修改 URL，同时不触发页面刷新。
- 当 URL 变化时，前端根据 URL 加载相应的组件或视图。

#### **优点**
- URL 美观：没有 `#`，看起来更简洁、规范。
- SEO 友好：能够让搜索引擎抓取页面内容（需要后端配合进行动态内容返回）。
- 更贴近真实的页面路径，用户体验更好。

#### **缺点**
- **需要后端支持**：当用户直接访问某个路径时（如 `/home`），服务器需要配置将所有请求返回到单一入口 HTML 文件。如果未配置，可能会返回 404 错误。
- 兼容性：需要支持 HTML5 的浏览器。

---

### **3. 核心区别对比**

| **对比点**   | **Hash 模式**                    | **History 模式**                       |
| ------------ | -------------------------------- | -------------------------------------- |
| **URL 表现** | 带 `#`，如 `/index.html#/home`   | 不带 `#`，如 `/home`                   |
| **依赖技术** | `hashchange` 事件                | HTML5 的 History API                   |
| **兼容性**   | 兼容性好，支持较旧浏览器         | 需要支持 HTML5 的浏览器                |
| **SEO**      | 不友好，搜索引擎无法直接抓取内容 | 友好，需要后端支持                     |
| **页面刷新** | 哈希变化不会引发页面刷新         | URL 改变也不会引发页面刷新             |
| **后端支持** | 不需要后端参与                   | 需要后端配置，将所有请求指向同一个入口 |

---

### **4. 使用场景**

- **Hash 模式**：适合对 SEO 要求不高的小型项目或快速开发的单页应用，且无需后端配置。
- **History 模式**：适合对 SEO 有需求的项目，或对用户体验要求较高的中大型项目（需要前后端配合）。

---

### **5. 总结**

- 如果追求简单和兼容性：选择 **Hash 模式**。
- 如果需要美观的 URL 和更好的 SEO 支持：选择 **History 模式**，但需配合后端实现。