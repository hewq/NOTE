在 Vue 3 中，`watch` 和 `watchEffect` 都是用于响应式数据变化时执行副作用的 API，它们看似有相似的用途，但在使用场景、原理和功能上有所不同。以下是两者的区别：

### 1. **watch**

#### 用途：

`watch` 用于监听某个响应式数据或计算属性的变化，并在变化时执行相应的副作用。

#### 特点：

- **明确的依赖**：`watch` 需要显式地传入一个被监听的对象或表达式，只有当这个对象的值发生变化时，才会触发回调函数。
- **适用于异步操作**：`watch` 允许你在回调中执行异步操作（如 `await`），而 `watchEffect` 适合同步操作。
- **只触发变更**：`watch` 只会在响应式数据的值变化时触发，不会在初次绑定时执行。

#### 语法：

```js
import { watch } from 'vue';

const count = ref(0);

watch(count, (newVal, oldVal) => {
  console.log('count changed:', newVal);
});
```

#### 使用场景：

- 当你需要监听某个特定数据或计算属性的变化时，并且在变化时做出响应。
- 当你需要获取旧值、新值或执行异步操作时，`watch` 更加合适。

### 2. **watchEffect**

#### 用途：

`watchEffect` 用于自动跟踪组件中响应式数据的变化并执行副作用。它不需要明确传入要观察的对象，而是会自动跟踪组件中访问的所有响应式数据。

#### 特点：

- **自动依赖追踪**：`watchEffect` 会在第一次执行时自动跟踪当前执行过程中访问的响应式数据，并且在这些数据发生变化时自动重新执行回调函数。
- **会在初次绑定时执行**：`watchEffect` 在初始化时会立即执行一次，这与 `watch` 不同，`watch` 只有在数据变化时才会执行。
- **适用于同步操作**：`watchEffect` 适用于同步副作用，如果需要执行异步操作，建议使用 `watch`。

#### 语法：

```js
import { watchEffect } from 'vue';

const count = ref(0);

watchEffect(() => {
  console.log('count changed:', count.value);
});
```

#### 使用场景：

- 当你想要在组件内执行副作用，并且不关心具体监听的哪些数据时，`watchEffect` 可以自动追踪依赖。
- 它适用于简单的副作用，比如打印日志、更新 UI 等。

### 3. **区别总结**

| 特性           | `watch`                                        | `watchEffect`                              |
| -------------- | ---------------------------------------------- | ------------------------------------------ |
| **依赖显式性** | 需要显式指定要监听的响应式数据或计算属性       | 自动追踪在回调函数中访问的响应式数据       |
| **触发时机**   | 只有数据变化时才触发                           | 初次执行时会立即触发，然后在依赖变化时触发 |
| **适用场景**   | 监听特定数据变化，并做出相应处理               | 自动处理副作用，适合不关心具体依赖时       |
| **回调函数**   | 接收新值和旧值作为参数                         | 只接收当前副作用，不接受新旧值参数         |
| **异步操作**   | 支持异步操作，`watch` 可以使用 `async`/`await` | 适合同步操作，不支持异步操作               |

### 4. **总结**

- **watch** 是一种更为明确的方式来监听某个数据的变化，它允许你处理数据变化前后的新旧值，并支持异步操作。
- **watchEffect** 是一种自动依赖追踪的方式，更适合用来处理简单的副作用，当你不关心具体依赖，只想对响应式数据做某些处理时，它会更加简洁和方便。