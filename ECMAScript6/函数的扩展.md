# 函数的扩展

- <a href="#1">函数参数的默认值</a>
- <a href="#2">rest 参数</a>
- <a href="#3">严格模式</a>
- <a href="#4">name 属性</a>
- <a href="#5">箭头函数</a>
- <a href="#6">双冒号运算符</a>
- <a href="#7">尾调用优化</a>
- <a href="#8">函数参数的尾逗号</a>

## <a name="1">函数参数的默认值</a>

### 基本用法

ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。

```javascript
	function log(x, y) {
		y = y || 'World';
		console.log(x, y);
	}

	log('Hello'); // Hello World
	log('Hello', 'China'); // Hello China
	log('Hello', ''); // Hello World  // 空字符串赋值不起作用
```

上面代码检查函数`log`的参数`y`有没有赋值，如果没有，则指定默认值为`World`。这种写法的缺点在于，如果给`y`赋值的是布尔值为`false`的值，则该赋值不起作用。为了避免这个问题，通常需要先判断一下`y`是否已经被赋值，如果没有，再等于默认值。

```javascript
if (typeof y === 'undefined') {
  y = 'World';
}
```

ES6 允许为函数的参数设置默认值，即直接写在函数定义的后面。

```javascript
	function log3(x, y = 'World') {
		console.log(x, y)
	}

	log3('Hello'); // Hello World
	log3('Hello', 'China'); // Hello China
	log3('Hello', ''); // Hello 
```

参数变量是默认声明的，不能用`let`或`const`再次声明。

```javascript
	function foo(x = 5) {
		let x = 1; // SyntaxError: Identifier 'x' has already been declared
		const x = 2; // SyntaxError: Identifier 'x' has already been declared
	}

	foo();
```

使用参数默认值时，函数不能有同名参数。

```javascript
	// 不报错
	function foo1(x, x, y) {
		console.log(x);
	}
	foo1(1, 2, 3);

	// 报错
	function foo2(x, x, y = 1) { // SyntaxError: Duplicate parameter name not allowed in this context
		console.log(x);
	}
```

另外，参数默认值每次都会重新计算，也就是说，参数默认值是惰性求值的。

```javascript
	let x = 99;
	function foo3(p = x + 1) {
		console.log(p);
	}
	foo3(); // 100
	x = 100;
	foo3(); // 101
```

### 与解构赋值默认值结合使用

参数默认值可以与解构赋值的默认值结合使用。

```javascript
	function foo({x, y = 5}) {
		console.log(x, y);
	}

	foo({}); // undefined 5
	foo({x: 1}); // 1 5
	foo({x: 1, y: 2}); // 1 2
	foo(); // TypeError: Cannot destructure property `x` of 'undefined' or 'null'.
```

上面代码只使用了解构赋值的默认值，没有使用函数参数的默认值。如果函数参数没有提供时，就不会生成`x`和`y`，从而报错。通过提供函数参数的默认值，避免这种情况。

```javascript
	function foo1({x, y = 5} = {}) {
		console.log(x, y);
	}

	foo1(); // undefined 5
```

下面是另一个解构赋值默认值的例子。

```javascript
function fetch(url, { body = '', method = 'GET', headers = {} }) {
		console.log(method);
	}
	fetch('http://example.com', {}); // GET
	// TypeError: Cannot destructure property `body` of 'undefined' or 'null'.
	fetch('http://example.com'); 
```

```javascript
	function fetch2(url, { body = '', method = 'GET', headers = {} } = {}) {
		console.log(method);
	}
	fetch2('http://example.com'); // GET
```

### 参数默认值的位置

通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。

```javascript
	function f(x = 1, y) {
		return [x, y];
	}

	console.log(f()); // [ 1, undefined ]
	console.log(f(2)); // [ 2, undefined ]
	console.log(f(, 1)); // SyntaxError: Unexpected token ,
	console.log(undefined, 1); // undefined 1

	function f2(x, y = 5, z) {
		return [x, y, z];
	}

	console.log(f2()); // [ undefined, 5, undefined ]
	console.log(f2(1)); // [ 1, 5, undefined ]
	console.log(f(1, ,2)); // SyntaxError: Unexpected token ,
	console.log(f2(1, undefined, 2)); // [ 1, 5, 2 ]
```

上面代码中，有默认值的参数都不是尾参数。这时，无法只省略该参数而不省略后面的参数，除非显式输入`undefined`。

如果传入`undefined`，将会触发该参数等于默认值，`null`则没效果。

```javascript
	function foo(x =5, y = 7) {
		console.log(x, y);
	}
	foo(undefined, null); // 5 null
```

### 函数的 length 属性

指定了默认值以后，函数的`length`属性将返回没有指定默认值的参数个数。也就是说，指定默认值后，`length`属性将失真。

```javascript
	console.log((function (a) {}).length); // 1
	console.log((function (a = 5) {}).length); // 0
	console.log((function (a, b, c = 5) {}).length); // 2
```

上面代码中，`length`属性等于函数参数个数减去指定默认值参数的个数。

这是因为`length`属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，后文的 rest 参数也不会就`length`属性。

```javascript 
	console.log((function (...args) {}).length); // 0
```

如果设置了默认值的参数不是尾参数，那么`length`属性也不再计入后面的参数了。

```javascript
	console.log((function (a = 0, b, c) {}).length); // 0
	console.log((function (a, b = 1, c) {}).length); // 1
```

## <a name="2">rest 参数</a>

## <a name="3">严格模式</a>

## <a name="4">name 属性</a>

## <a name="5">箭头函数</a>

## <a name="6">双冒号运算符</a>

## <a name="7">尾调用优化</a>

## <a name="8">函数参数的尾逗号</a>