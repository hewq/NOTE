# 函数的扩展

- <a href="#1">函数参数的默认值</a>
- <a href="#2">rest 参数</a>
- <a href="#3">严格模式</a>
- <a href="#4">name 属性</a>
- <a href="#5">箭头函数</a>
- <a href="#6">双冒号运算符</a>
- <a href="#7">尾调用优化</a>
- <a href="#8">函数参数的尾逗号</a>

## <a name="1">函数参数的默认值</a>

### 基本用法

ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。

```javascript
	function log(x, y) {
		y = y || 'World';
		console.log(x, y);
	}

	log('Hello'); // Hello World
	log('Hello', 'China'); // Hello China
	log('Hello', ''); // Hello World  // 空字符串赋值不起作用
```

上面代码检查函数`log`的参数`y`有没有赋值，如果没有，则指定默认值为`World`。这种写法的缺点在于，如果给`y`赋值的是布尔值为`false`的值，则该赋值不起作用。为了避免这个问题，通常需要先判断一下`y`是否已经被赋值，如果没有，再等于默认值。

```javascript
if (typeof y === 'undefined') {
  y = 'World';
}
```

ES6 允许为函数的参数设置默认值，即直接写在函数定义的后面。

```javascript
	function log3(x, y = 'World') {
		console.log(x, y)
	}

	log3('Hello'); // Hello World
	log3('Hello', 'China'); // Hello China
	log3('Hello', ''); // Hello 
```

参数变量是默认声明的，不能用`let`或`const`再次声明。

```javascript
	function foo(x = 5) {
		let x = 1; // SyntaxError: Identifier 'x' has already been declared
		const x = 2; // SyntaxError: Identifier 'x' has already been declared
	}

	foo();
```

使用参数默认值时，函数不能有同名参数。

```javascript
	// 不报错
	function foo1(x, x, y) {
		console.log(x);
	}
	foo1(1, 2, 3);

	// 报错
	function foo2(x, x, y = 1) { // SyntaxError: Duplicate parameter name not allowed in this context
		console.log(x);
	}
```

另外，参数默认值每次都会重新计算，也就是说，参数默认值是惰性求值的。

```javascript
	let x = 99;
	function foo3(p = x + 1) {
		console.log(p);
	}
	foo3(); // 100
	x = 100;
	foo3(); // 101
```

### 与解构赋值默认值结合使用

参数默认值可以与解构赋值的默认值结合使用。

```javascript
	function foo({x, y = 5}) {
		console.log(x, y);
	}

	foo({}); // undefined 5
	foo({x: 1}); // 1 5
	foo({x: 1, y: 2}); // 1 2
	foo(); // TypeError: Cannot destructure property `x` of 'undefined' or 'null'.
```

上面代码只使用了解构赋值的默认值，没有使用函数参数的默认值。如果函数参数没有提供时，就不会生成`x`和`y`，从而报错。通过提供函数参数的默认值，避免这种情况。

```javascript
	function foo1({x, y = 5} = {}) {
		console.log(x, y);
	}

	foo1(); // undefined 5
```

下面是另一个解构赋值默认值的例子。

```javascript
function fetch(url, { body = '', method = 'GET', headers = {} }) {
		console.log(method);
	}
	fetch('http://example.com', {}); // GET
	// TypeError: Cannot destructure property `body` of 'undefined' or 'null'.
	fetch('http://example.com'); 
```

```javascript
	function fetch2(url, { body = '', method = 'GET', headers = {} } = {}) {
		console.log(method);
	}
	fetch2('http://example.com'); // GET
```

### 参数默认值的位置

通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。

```javascript
	function f(x = 1, y) {
		return [x, y];
	}

	console.log(f()); // [ 1, undefined ]
	console.log(f(2)); // [ 2, undefined ]
	console.log(f(, 1)); // SyntaxError: Unexpected token ,
	console.log(undefined, 1); // undefined 1

	function f2(x, y = 5, z) {
		return [x, y, z];
	}

	console.log(f2()); // [ undefined, 5, undefined ]
	console.log(f2(1)); // [ 1, 5, undefined ]
	console.log(f(1, ,2)); // SyntaxError: Unexpected token ,
	console.log(f2(1, undefined, 2)); // [ 1, 5, 2 ]
```

上面代码中，有默认值的参数都不是尾参数。这时，无法只省略该参数而不省略后面的参数，除非显式输入`undefined`。

如果传入`undefined`，将会触发该参数等于默认值，`null`则没效果。

```javascript
	function foo(x =5, y = 7) {
		console.log(x, y);
	}
	foo(undefined, null); // 5 null
```

### 函数的 length 属性

指定了默认值以后，函数的`length`属性将返回没有指定默认值的参数个数。也就是说，指定默认值后，`length`属性将失真。

```javascript
	console.log((function (a) {}).length); // 1
	console.log((function (a = 5) {}).length); // 0
	console.log((function (a, b, c = 5) {}).length); // 2
```

上面代码中，`length`属性等于函数参数个数减去指定默认值参数的个数。

这是因为`length`属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，后文的 rest 参数也不会就`length`属性。

```javascript 
	console.log((function (...args) {}).length); // 0
```

如果设置了默认值的参数不是尾参数，那么`length`属性也不再计入后面的参数了。

```javascript
	console.log((function (a = 0, b, c) {}).length); // 0
	console.log((function (a, b = 1, c) {}).length); // 1
```

### 作用域

一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。

```javascript
var x = 1;

function f(x, y = x) {
  console.log(y);
}
f(2); // 2
```

上面代码中，参数`y`的默认值等于变量`x`。调用函数`f`时，参数形成一个单独的作用域。在这个作用域里，默认值变量`x`指向第一个参数`x`，而不是全局变量`x`，所以输出是`2`。

```javascript
	let a = 1;

	function f1(b = a) {
		let a = 2;
		console.log(b);
	}
	f1(); // 1
```

上面代码中，函数`f1`调用时，参数`b=a`形成一个单独的作用域。这个作用域里面，变量`a`本身没有定义，所以指向外层的全局变量`a`。函数调用时，函数体内部的局部变量`a`影响不到默认值变量`x`。

如果此时，全局变量`a`不存在，就会报错。

```javascript
function f1(b = a) {
  let a = 2;
  console.log(b);
}
f1(); // ReferenceError: a is not defined
```

下面这样写，也会报错。

```javascript
	var m = 1;
	function foo(m = m) {
		console.log(1);
	}
	foo(); // ReferenceError: m is not defined
```

上面代码中，参数`m = m`形成一个单独作用域。实际执行的是`let x = x`，由于暂时性死区的原因，这行代码会报错"m 未定义"。

如果参数的默认值是一个函数，该函数的作用域也遵守这个规则。请看下面的例子。

```javascript
	let baz = 'outer';

	function bar(func = () => baz) {
		let baz = 'inner';
		console.log(func())
	}
	bar(); // outer
```

上面代码中，函数`bar`的参数`func`的默认值是一个匿名函数，返回值为变量`baz`。函数参数形成的单独作用域里面，并没有定义变量`baz`。函数参数形成的单独作用域里面，并没有定义变量`baz`，所以`baz`指向外层的全局变量`baz`，因此输出`outer`。

如果写成下面这样，就会报错。

```javascript
function bar(func = () => baz) {
  let baz = 'inner';
  console.log(func());
}
bar(); // ReferenceError: baz is not defined
```

上面代码中，匿名函数里面的`baz`指向函数外层，但是函数外层并没有声明变量`baz`，所以就报错。

下面是一个更复杂的例子。

```javascript
	var x = 1;
	function foo(x, y = function () { x = 2; }) {
		var x = 3;
		y();
		console.log(x);
	}
	foo(); // 3
	console.log(x); // 1
```

上面代码中，函数`foo`的参数形成一个单独的作用域。这个作用域里面，首先声明了变量`x`，然后声明了变量`y`，`y`的默认值是一个匿名函数。这个匿名函数内部的变量`x`，指向同一个作用域的第一个参数`x`。函数`foo`内部又声明了一个内部变量`x`，该变量与第一个参数`x`由于不是同一个作用域，所以不是同一个变量，因此执行`y`后，内部变量`x`和外部全局变量`x`的值都没变。

如果将`var x = 3`的`var`去除，函数`foo`的内部变量`x`就指向第一个参数`x`，与匿名函数内部的`x`是一致的，所以最后输出的就是`2`，而外层的全局变量`x`依然不受影响。

```javascript
var x = 1;
function foo(x, y = function() { x = 2 }) {
  x = 3;
  y();
  console.log(x);
}
foo(); // 2
console.log(x); // 1
```

### 应用

利用参数默认值，可以指定一个参数不得省略，如果省略就抛出一个错误。

```javascript
	function throwIfMissing() {
		throw new Error('Missing parameter');
	}

	function foo(mustBeProvided = throwIfMissing()) {
		return mustBeProvided;
	}

	foo(); // Error: Missing parameter
```

上面代码的`foo`函数，如果调用的时候没有参数，就会调用默认值`throwIfMissing`函数，从而抛出一个错误。

从上面代码还可以看到，参数`mustBeProvided`的默认值等于`throwIfMissing`函数的运行结果（注意函数名`throwIfMissing`之后有一对圆括号），这表明参数的默认值不是在定义时执行，而是在运行时执行。如果参数已经赋值，默认值中的函数就不会运行。

另外，可以将参数默认值设为`undefined`，表明这个参数是可以省略的。

```javascript
function foo(optional = undefined) {...}
```

[code](<https://github.com/hewq/ECMAScript6/blob/master/apps/n07funcextend/n01.js>)

## <a name="2">rest 参数</a>

ES6 引入 rest 参数（形式为`...变量名`），用于获取函数的多余参数，这样就不需要使用`arguments`对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。

```javascript
	function add(...values) {
		let sum = 0;

		for (var val of values) {
			sum += val;
		}

		return sum;
	}

	console.log(add(2, 5, 3)); // 10
```

上面代码的`add`函数是一个求和函数，利用 rest 参数，可以向该函数传入任意数目的参数。

下面是一个 rest 参数代替`arguments`变量的例子。

```javascript
	// arguments 变量的写法
	function sortNumbers() {
		return Array.prototype.slice.call(arguments).sort();
	}

	// rest 参数的写法
	const sortNumbersRest = (...numbers) => numbers.sort();
```

上面代码的两种写法，比较后可以发现，rest 参数的写法更自然也更简洁。

`arguments`对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用`Array.prototype.slice.call`先将其转为数组。rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。下面是一个利用 rest 参数改写数组`push`方法的例子。

```javascript
	function push(array, ...items) {
		items.forEach(function (item) {
			array.push(item);
			console.log(item);
		});
	}

	var a = [];
	push(a, 1, 2, 3);
```

注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。

```javascript
	function f(a, ...b, c) { // SyntaxError: Rest parameter must be last formal parameter

	}
```

函数的`length`属性，不包括 rest 参数。

```javascript
	console.log((function (a) {}).length); // 1
	console.log((function (...a) {}).length); // 0
	console.log((function (a, ...b) {}).length); // 1
```

[code](<https://github.com/hewq/ECMAScript6/blob/master/apps/n07funcextend/n02.js>)

## <a name="3">严格模式</a> [（什么是严格模式）](<https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode>)

从 ES5 开始，函数内部可以设定为严格模式。

```javascript
	function doSomething(a, b) {
		'use strict';
		// code
	}
```

ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显示设定为严格模式，否则会报错。

```javascript
	// 报错
	function doSomething(a, b = a) { // SyntaxError: Illegal 'use strict' directive in function with non-simple parameter list
		'use strict';
		// code
	}
	
	const doSomething = function ({a, b}) { // SyntaxError: Illegal 'use strict' directive in function with non-simple parameter list
		'use strict';
		// code
	}
	
	const doSomething = (...a) => { // SyntaxError: Illegal 'use strict' directive in function with non-simple parameter list
		'use strict';
		// code
	}

	const obj = {
		// 报错
		doSomething({a, b}) {
			'use strict'; // SyntaxError: Illegal 'use strict' directive in function with non-simple parameter list
			// code
		}
	}

```

这样规定的原因是，函数内部的严格模式，同时适用于函数体和函数参数。但是，函数执行的时候，先执行函数参数，然后再执行函数体。这样就有一个不合理的地方，只有从函数体之中，才能知道参数是否应该以严格模式执行，但是参数却应该先于函数体执行。

```javascript
	// 报错
	function doSomething(value = 070) {
		'use strict'; // SyntaxError: Illegal 'use strict' directive in function with non-simple parameter list
		return value;
	}
```

上面代码中，参数`value`的默认值是八进制数`070`，但是严格模式下不能用前缀`0`表示八进制，所以应该报错。但是实际上，JavaScript 引擎会先成功执行`value = 070`，然后进入函数体内部，发现需要用严格模式执行，这时才会报错。

虽然可以先解析函数体代码，再执行参数代码，但是这样无疑就增加了复杂性。因此，标准索性禁止了这种用法，只要参数使用了默认值、解构赋值、或者扩展运算符，就不能显示指定严格模式。

两种方法可以避免这种限制。第一种是设定全局性的严格模式，这是合法的。

```javascript
'use strict';

function doSomething(a, b = a) {
  // code
}
```

第二种是把函数包在一个无参数的立即执行函数里面。

```javascript
const doSomething = (function () {
  'use strict';
  return function(value = 42) {
    return value;
  }
}());
```

[code](<https://github.com/hewq/ECMAScript6/blob/master/apps/n07funcextend/n03.js>)

## <a name="4">name 属性</a>

## <a name="5">箭头函数</a>

## <a name="6">双冒号运算符</a>

## <a name="7">尾调用优化</a>

## <a name="8">函数参数的尾逗号</a>